// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TimingSequenceInfo The info according to which the temporal relation between two panels is determined. The observations identified by the first panel occur before the observations identified by the second panel if the {whichDateFirst} of the {whichObservationFirst} observation in the first panel occurs {when} the {whichDateSecond} of the {whichObservationSecond} observation in the second panel.
//
// swagger:model timingSequenceInfo
type TimingSequenceInfo struct {

	// spans
	Spans []*TimingSequenceSpan `json:"spans"`

	// when
	// Required: true
	// Enum: [LESS LESSEQUAL EQUAL]
	When *string `json:"when"`

	// which date first
	// Required: true
	// Enum: [STARTDATE ENDDATE]
	WhichDateFirst *string `json:"whichDateFirst"`

	// which date second
	// Required: true
	// Enum: [STARTDATE ENDDATE]
	WhichDateSecond *string `json:"whichDateSecond"`

	// which observation first
	// Required: true
	// Enum: [FIRST LAST ANY]
	WhichObservationFirst *string `json:"whichObservationFirst"`

	// which observation second
	// Required: true
	// Enum: [FIRST LAST ANY]
	WhichObservationSecond *string `json:"whichObservationSecond"`
}

// Validate validates this timing sequence info
func (m *TimingSequenceInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSpans(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWhen(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWhichDateFirst(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWhichDateSecond(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWhichObservationFirst(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWhichObservationSecond(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TimingSequenceInfo) validateSpans(formats strfmt.Registry) error {

	if swag.IsZero(m.Spans) { // not required
		return nil
	}

	for i := 0; i < len(m.Spans); i++ {
		if swag.IsZero(m.Spans[i]) { // not required
			continue
		}

		if m.Spans[i] != nil {
			if err := m.Spans[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("spans" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var timingSequenceInfoTypeWhenPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LESS","LESSEQUAL","EQUAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		timingSequenceInfoTypeWhenPropEnum = append(timingSequenceInfoTypeWhenPropEnum, v)
	}
}

const (

	// TimingSequenceInfoWhenLESS captures enum value "LESS"
	TimingSequenceInfoWhenLESS string = "LESS"

	// TimingSequenceInfoWhenLESSEQUAL captures enum value "LESSEQUAL"
	TimingSequenceInfoWhenLESSEQUAL string = "LESSEQUAL"

	// TimingSequenceInfoWhenEQUAL captures enum value "EQUAL"
	TimingSequenceInfoWhenEQUAL string = "EQUAL"
)

// prop value enum
func (m *TimingSequenceInfo) validateWhenEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, timingSequenceInfoTypeWhenPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TimingSequenceInfo) validateWhen(formats strfmt.Registry) error {

	if err := validate.Required("when", "body", m.When); err != nil {
		return err
	}

	// value enum
	if err := m.validateWhenEnum("when", "body", *m.When); err != nil {
		return err
	}

	return nil
}

var timingSequenceInfoTypeWhichDateFirstPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STARTDATE","ENDDATE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		timingSequenceInfoTypeWhichDateFirstPropEnum = append(timingSequenceInfoTypeWhichDateFirstPropEnum, v)
	}
}

const (

	// TimingSequenceInfoWhichDateFirstSTARTDATE captures enum value "STARTDATE"
	TimingSequenceInfoWhichDateFirstSTARTDATE string = "STARTDATE"

	// TimingSequenceInfoWhichDateFirstENDDATE captures enum value "ENDDATE"
	TimingSequenceInfoWhichDateFirstENDDATE string = "ENDDATE"
)

// prop value enum
func (m *TimingSequenceInfo) validateWhichDateFirstEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, timingSequenceInfoTypeWhichDateFirstPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TimingSequenceInfo) validateWhichDateFirst(formats strfmt.Registry) error {

	if err := validate.Required("whichDateFirst", "body", m.WhichDateFirst); err != nil {
		return err
	}

	// value enum
	if err := m.validateWhichDateFirstEnum("whichDateFirst", "body", *m.WhichDateFirst); err != nil {
		return err
	}

	return nil
}

var timingSequenceInfoTypeWhichDateSecondPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STARTDATE","ENDDATE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		timingSequenceInfoTypeWhichDateSecondPropEnum = append(timingSequenceInfoTypeWhichDateSecondPropEnum, v)
	}
}

const (

	// TimingSequenceInfoWhichDateSecondSTARTDATE captures enum value "STARTDATE"
	TimingSequenceInfoWhichDateSecondSTARTDATE string = "STARTDATE"

	// TimingSequenceInfoWhichDateSecondENDDATE captures enum value "ENDDATE"
	TimingSequenceInfoWhichDateSecondENDDATE string = "ENDDATE"
)

// prop value enum
func (m *TimingSequenceInfo) validateWhichDateSecondEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, timingSequenceInfoTypeWhichDateSecondPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TimingSequenceInfo) validateWhichDateSecond(formats strfmt.Registry) error {

	if err := validate.Required("whichDateSecond", "body", m.WhichDateSecond); err != nil {
		return err
	}

	// value enum
	if err := m.validateWhichDateSecondEnum("whichDateSecond", "body", *m.WhichDateSecond); err != nil {
		return err
	}

	return nil
}

var timingSequenceInfoTypeWhichObservationFirstPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FIRST","LAST","ANY"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		timingSequenceInfoTypeWhichObservationFirstPropEnum = append(timingSequenceInfoTypeWhichObservationFirstPropEnum, v)
	}
}

const (

	// TimingSequenceInfoWhichObservationFirstFIRST captures enum value "FIRST"
	TimingSequenceInfoWhichObservationFirstFIRST string = "FIRST"

	// TimingSequenceInfoWhichObservationFirstLAST captures enum value "LAST"
	TimingSequenceInfoWhichObservationFirstLAST string = "LAST"

	// TimingSequenceInfoWhichObservationFirstANY captures enum value "ANY"
	TimingSequenceInfoWhichObservationFirstANY string = "ANY"
)

// prop value enum
func (m *TimingSequenceInfo) validateWhichObservationFirstEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, timingSequenceInfoTypeWhichObservationFirstPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TimingSequenceInfo) validateWhichObservationFirst(formats strfmt.Registry) error {

	if err := validate.Required("whichObservationFirst", "body", m.WhichObservationFirst); err != nil {
		return err
	}

	// value enum
	if err := m.validateWhichObservationFirstEnum("whichObservationFirst", "body", *m.WhichObservationFirst); err != nil {
		return err
	}

	return nil
}

var timingSequenceInfoTypeWhichObservationSecondPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FIRST","LAST","ANY"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		timingSequenceInfoTypeWhichObservationSecondPropEnum = append(timingSequenceInfoTypeWhichObservationSecondPropEnum, v)
	}
}

const (

	// TimingSequenceInfoWhichObservationSecondFIRST captures enum value "FIRST"
	TimingSequenceInfoWhichObservationSecondFIRST string = "FIRST"

	// TimingSequenceInfoWhichObservationSecondLAST captures enum value "LAST"
	TimingSequenceInfoWhichObservationSecondLAST string = "LAST"

	// TimingSequenceInfoWhichObservationSecondANY captures enum value "ANY"
	TimingSequenceInfoWhichObservationSecondANY string = "ANY"
)

// prop value enum
func (m *TimingSequenceInfo) validateWhichObservationSecondEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, timingSequenceInfoTypeWhichObservationSecondPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TimingSequenceInfo) validateWhichObservationSecond(formats strfmt.Registry) error {

	if err := validate.Required("whichObservationSecond", "body", m.WhichObservationSecond); err != nil {
		return err
	}

	// value enum
	if err := m.validateWhichObservationSecondEnum("whichObservationSecond", "body", *m.WhichObservationSecond); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TimingSequenceInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TimingSequenceInfo) UnmarshalBinary(b []byte) error {
	var res TimingSequenceInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
