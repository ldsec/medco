-- this function returns (at most @lim) ontology elements whose paths contain @search_string.

CREATE OR REPLACE FUNCTION medco_ont.get_ontology_elements(search_string varchar, lim integer DEFAULT 10)
      RETURNS TABLE (
        c_fullname varchar,
        c_name varchar,
        c_visualattributes char(3),
        c_basecode varchar,
        c_metadataxml text,
        c_comment text,
        m_applied_path varchar)
    LANGUAGE 'plpgsql'
    VOLATILE
    PARALLEL SAFE
AS $BODY$
DECLARE
      rec record;
      strSQL text;
BEGIN

	strSQL := '';

    -- create statement to retrieve all matching concepts from all tables in medco_ont.table_access
    -- and store them into the temporary table "ontology_elements"
    FOR rec IN SELECT DISTINCT c_table_name FROM medco_ont.table_access
    LOOP
		strSQL := strSQL || 'SELECT c_fullname, c_name, c_visualattributes, c_basecode, c_metadataxml, c_comment, m_applied_path
          		FROM medco_ont.' || lower(rec.c_table_name) || '
         		WHERE lower(c_name) LIKE $1
				UNION ALL ';
    END LOOP;
    strSQL := 'CREATE TEMP TABLE ontology_elements AS '  || trim(trailing ' UNION ALL ' from strSQL) || ' ORDER BY c_fullname LIMIT $2;';

    -- execute the statement
	EXECUTE strSQL USING '%' || lower(search_string) || '%', lim;

	-- retrieve the table_cd(s) given the c_fullname(s) found in the previous step
	-- and prepend them to the c_fullname(s) in the temporary table "ontology_elements"
	FOR rec IN SELECT ontology_elements.c_fullname FROM ontology_elements
	LOOP
		strSQL := (SELECT c_table_cd
		FROM medco_ont.table_access AS ta
		WHERE POSITION(ta.c_fullname IN rec.c_fullname) > 0
		ORDER BY LENGTH(ta.c_fullname) DESC
		LIMIT 1);

		UPDATE ontology_elements
		SET c_fullname = '\\' || strSQL || ontology_elements.c_fullname
		WHERE ontology_elements.c_fullname = rec.c_fullname;
	END LOOP;

	-- return the temporary table "ontology_elements" and drop it
	RETURN QUERY SELECT * FROM ontology_elements;
	DROP TABLE ontology_elements;

END;
$BODY$;